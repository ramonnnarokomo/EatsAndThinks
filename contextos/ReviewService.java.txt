package com.eatsandthinks.demo.service;

import com.eatsandthinks.demo.entity.LocalEntity;
import com.eatsandthinks.demo.entity.Review;
import com.eatsandthinks.demo.entity.User;
import com.eatsandthinks.demo.repository.LocalRepository;
import com.eatsandthinks.demo.repository.ReviewRepository;
import com.eatsandthinks.demo.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class ReviewService {

    private final ReviewRepository reviewRepository;
    private final LocalRepository localRepository;
    private final UserRepository userRepository;

    public ReviewService(ReviewRepository reviewRepository, 
                        LocalRepository localRepository,
                        UserRepository userRepository) {
        this.reviewRepository = reviewRepository;
        this.localRepository = localRepository;
        this.userRepository = userRepository;
    }

    /**
     * Crea una nueva rese√±a y guarda el local si no existe
     */
    @Transactional
    public ReviewDTO createReview(ReviewCreationDTO dto) {
        System.out.println("üìù Creando rese√±a para local: " + dto.localData().nombre());
        
        // 1. Buscar o crear el Local
        LocalEntity local = localRepository.findByPlaceId(dto.localData().placeId())
            .orElseGet(() -> {
                System.out.println("üÜï Creando nuevo local en BD: " + dto.localData().nombre());
                LocalEntity newLocal = new LocalEntity();
                newLocal.setPlaceId(dto.localData().placeId());
                newLocal.setNombre(dto.localData().nombre());
                newLocal.setDireccion(dto.localData().direccion());
                newLocal.setTipo(dto.localData().tipo());
                newLocal.setLatitud(dto.localData().lat());
                newLocal.setLongitud(dto.localData().lng());
                newLocal.setPrecioNivel(dto.localData().priceLevel());
                newLocal.setFotoRef(dto.localData().photoRef());
                newLocal.setSource(LocalEntity.Source.GOOGLE);
                return localRepository.save(newLocal);
            });

        // 2. Verificar que el usuario existe
        User user = userRepository.findById(dto.userId())
            .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        // 3. Crear la rese√±a
        Review review = new Review();
        review.setUserId(dto.userId());
        review.setLocalId(local.getId());
        review.setPuntuacion(dto.puntuacion());
        review.setComentario(dto.comentario());
        review.setFecha(LocalDateTime.now());

        Review savedReview = reviewRepository.save(review);
        
        // 4. Actualizar rating del local
        updateLocalRating(local.getId());

        System.out.println("‚úÖ Rese√±a creada con ID: " + savedReview.getId());
        
        return new ReviewDTO(
            savedReview.getId(),
            savedReview.getPuntuacion(),
            savedReview.getComentario(),
            savedReview.getFecha(),
            savedReview.getUserId(),
            user.getNombre(),
            local.getPlaceId()
        );
    }

    /**
     * Obtiene todas las rese√±as de un local por placeId
     */
    public List<ReviewDTO> getReviewsByLocalPlaceId(String placeId) {
        System.out.println("üîç Buscando rese√±as para placeId: " + placeId);
        
        LocalEntity local = localRepository.findByPlaceId(placeId)
            .orElse(null);
        
        if (local == null) {
            System.out.println("‚ö†Ô∏è Local no encontrado en BD");
            return List.of();
        }

        List<Review> reviews = reviewRepository.findByLocalId(local.getId());
        System.out.println("‚úÖ Encontradas " + reviews.size() + " rese√±as");
        
        return reviews.stream()
            .map(r -> {
                User user = userRepository.findById(r.getUserId()).orElse(null);
                String authorName = user != null ? user.getNombre() : "Usuario An√≥nimo";
                return new ReviewDTO(
                    r.getId(),
                    r.getPuntuacion(),
                    r.getComentario(),
                    r.getFecha(),
                    r.getUserId(),
                    authorName,
                    placeId
                );
            })
            .collect(Collectors.toList());
    }

    /**
     * Obtiene todas las rese√±as de un usuario
     */
    public List<ReviewDTO> getReviewsByUserId(Long userId) {
        System.out.println("üîç Buscando rese√±as del usuario: " + userId);
        
        List<Review> reviews = reviewRepository.findByUserId(userId);
        
        return reviews.stream()
            .map(r -> {
                LocalEntity local = localRepository.findById(r.getLocalId()).orElse(null);
                User user = userRepository.findById(r.getUserId()).orElse(null);
                
                return new ReviewDTO(
                    r.getId(),
                    r.getPuntuacion(),
                    r.getComentario(),
                    r.getFecha(),
                    r.getUserId(),
                    user != null ? user.getNombre() : "Usuario",
                    local != null ? local.getPlaceId() : null,
                    local != null ? local.getNombre() : "Local eliminado"
                );
            })
            .collect(Collectors.toList());
    }

    /**
     * Actualiza una rese√±a existente
     */
    @Transactional
    public ReviewDTO updateReview(Long reviewId, ReviewUpdateDTO dto, Long userId) {
        System.out.println("üìù Actualizando rese√±a ID: " + reviewId);
        
        Review review = reviewRepository.findById(reviewId)
            .orElseThrow(() -> new RuntimeException("Rese√±a no encontrada"));
        
        // Verificar que el usuario es el autor
        if (!review.getUserId().equals(userId)) {
            throw new RuntimeException("No tienes permisos para editar esta rese√±a");
        }

        review.setPuntuacion(dto.puntuacion());
        review.setComentario(dto.comentario());
        review.setFecha(LocalDateTime.now()); // Actualizar fecha de modificaci√≥n
        
        Review updated = reviewRepository.save(review);
        
        // Actualizar rating del local
        updateLocalRating(review.getLocalId());
        
        User user = userRepository.findById(updated.getUserId()).orElse(null);
        LocalEntity local = localRepository.findById(updated.getLocalId()).orElse(null);
        
        System.out.println("‚úÖ Rese√±a actualizada");
        
        return new ReviewDTO(
            updated.getId(),
            updated.getPuntuacion(),
            updated.getComentario(),
            updated.getFecha(),
            updated.getUserId(),
            user != null ? user.getNombre() : "Usuario",
            local != null ? local.getPlaceId() : null
        );
    }

    /**
     * Elimina una rese√±a
     */
    @Transactional
    public void deleteReview(Long reviewId, Long userId) {
        System.out.println("üóëÔ∏è Eliminando rese√±a ID: " + reviewId);
        
        Review review = reviewRepository.findById(reviewId)
            .orElseThrow(() -> new RuntimeException("Rese√±a no encontrada"));
        
        // Verificar que el usuario es el autor
        if (!review.getUserId().equals(userId)) {
            throw new RuntimeException("No tienes permisos para eliminar esta rese√±a");
        }

        Long localId = review.getLocalId();
        reviewRepository.delete(review);
        
        // Actualizar rating del local
        updateLocalRating(localId);
        
        System.out.println("‚úÖ Rese√±a eliminada");
    }

    /**
     * Actualiza el rating promedio de un local basado en sus rese√±as
     */
    private void updateLocalRating(Long localId) {
        List<Review> reviews = reviewRepository.findByLocalId(localId);
        
        if (reviews.isEmpty()) {
            return;
        }
        
        double avgRating = reviews.stream()
            .mapToInt(Review::getPuntuacion)
            .average()
            .orElse(0.0);
        
        LocalEntity local = localRepository.findById(localId).orElse(null);
        if (local != null) {
            local.setRating(avgRating);
            local.setTotalValoraciones(reviews.size());
            localRepository.save(local);
            System.out.println("üìä Rating actualizado: " + avgRating + " (" + reviews.size() + " rese√±as)");
        }
    }

    // ========== DTOs ==========
    
    public record ReviewCreationDTO(
        Integer puntuacion,
        String comentario,
        Long userId,
        LocalData localData
    ) {}
    
    public record LocalData(
        String placeId,
        String nombre,
        String direccion,
        String tipo,
        Double lat,
        Double lng,
        Integer priceLevel,
        String photoRef
    ) {}

    public record ReviewDTO(
        Long reviewId,
        Integer puntuacion,
        String comentario,
        LocalDateTime fecha,
        Long userId,
        String author,
        String placeId,
        String restaurantName
    ) {
        // Constructor alternativo sin restaurantName
        public ReviewDTO(Long reviewId, Integer puntuacion, String comentario, 
                        LocalDateTime fecha, Long userId, String author, String placeId) {
            this(reviewId, puntuacion, comentario, fecha, userId, author, placeId, null);
        }
    }

    public record ReviewUpdateDTO(
        Integer puntuacion,
        String comentario
    ) {}
}